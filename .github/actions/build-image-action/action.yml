name: preset-common-image-build

description: "A reusable workflow for building preset images"

inputs:
  weights_dir:
    description: "The directory for weights"
    required: true
  branch_name: 
    description: "Branch name"
    required: true
  image_name:
    description: "Image name"
    required: true
  image_tag:
    description: "Image tag"
    required: true
  acr_name:
    description: "ACR name"
    required: true
  acr_username:
    description: "ACR username"
    required: true
  acr_password:
    description: "ACR password"
    required: true
  model_name:
    description: "Model name"
    required: true
  model_type:
    description: "Model type"
    required: true
  model_version:
    description: "Model version"
    required: true
  model_runtime:
    description: "Model runtime"
    required: true
  image_already_built:
    description: "Indicate if the image is already built"
    required: true
  runs_on:
    description: "The runner to use"
    required: true

runs:
  using: "composite"
  steps:
    - name: Checkout
      uses: actions/checkout@v4.1.6
      with:
        submodules: true
        fetch-depth: 0

    - name: Install Azure CLI latest
      run: |
        if ! which az > /dev/null; then
          echo "Azure CLI not found. Installing..."
          curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
        else
          echo "Azure CLI already installed."
        fi
      shell: bash

    - name: Check Available Disk Space
      run: |
        echo "Initial disk usage:"
        df -h

        # Remove unused Docker resources
        docker system prune -a -f --volumes

        # Check Docker-related disk usage after cleanup
        echo "Docker-related disk usage after cleanup:"
        docker system df

        # Check final disk usage
        echo "Final disk usage:"
        df -h
      shell: bash

    - name: Ensure Docker is Installed
      run: |
        # Add Docker's official GPG key:
        sudo apt-get update
        sudo apt-get install ca-certificates curl -y
        sudo install -m 0755 -d /etc/apt/keyrings
        sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
        sudo chmod a+r /etc/apt/keyrings/docker.asc
        
        # Add the repository to Apt sources:
        echo \
          "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
          $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
          sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
        sudo apt-get update

        sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin -y
        
        # User Permissions
        sudo usermod -aG docker $(whoami)
        sudo systemctl restart docker
        sudo chmod 666 /var/run/docker.sock
      shell: bash
    
    - name: Test Docker Access
      run: |
        ls -l /var/run/docker.sock
        docker run hello-world
      shell: bash
      
    - name: Check and Create Kind Cluster
      run: |
        if ! kind get clusters | grep -q kind; then
          # Always delete the existing Kind cluster (if any)
          # kind delete cluster

          # Ensure deletion
          # sleep 15

          echo "Creating directory for etcd storage"
          sudo mkdir -p /mnt/storage/etcd
          echo "Creating Kind cluster using kind-1es.yaml"
          kind create cluster --config .github/workflows/kind-cluster/kind-1es.yaml

          # Retrieve the kubeconfig content for the kind cluster
          # KUBECONFIG_CONTENT=$(kind get kubeconfig --name="kind")

          # if [ -z "$KUBECONFIG_CONTENT" ]; then
          #   echo "Failed to retrieve the kubeconfig content."
          #   exit 1
          # fi

          # # Write the kubeconfig content to a temporary file
          # echo "$KUBECONFIG_CONTENT" > /tmp/kubeconfig

          # # Set the correct permissions for the kubeconfig file
          # chmod 600 /tmp/kubeconfig

          # # Extract the server URL from the kubeconfig content using yq
          # KUBERNETES_CONTROL_PLANE_URL=$(echo "$KUBECONFIG_CONTENT" | yq eval '.clusters[0].cluster.server' -)

          # if [ -z "$KUBERNETES_CONTROL_PLANE_URL" ]; then
          #   echo "Failed to retrieve the control plane URL."
          #   exit 1
          # fi

          # echo "Kubernetes control plane URL: $KUBERNETES_CONTROL_PLANE_URL"

          # # Update the kubeconfig file with the correct URL
          # sed -i "s|server: .*|server: $KUBERNETES_CONTROL_PLANE_URL|" /tmp/kubeconfig

          # # Set the KUBECONFIG environment variable to the temporary kubeconfig file
          # export KUBECONFIG=/tmp/kubeconfig

          # # Set the context to use the updated cluster
          # kubectl config use-context kind-kind

          # # Verify the Kubernetes configuration
          # kubectl cluster-info
        else
          echo "Kind cluster already exists"
        fi
        kubectl cluster-info --context kind-kind
      shell: bash

    - name: Check if Image exists in target ACR
      id: check_test_image
      run: |
        ACR_NAME=${{ inputs.acr_name }}
        IMAGE_NAME=${{ inputs.image_name }}
        TAG=${{ inputs.image_tag }}

        # Use '|| true' to prevent script from exiting with an error if the repository is not found
        TAGS=$(az acr repository show-tags -n $ACR_NAME --repository $IMAGE_NAME --output tsv || true)

        if [[ -z "$TAGS" ]]; then
          echo "Image $IMAGE_NAME:$TAG or repository not found in $ACR_NAME."
          echo "IMAGE_EXISTS=false" >> $GITHUB_OUTPUT
        else
          if echo "$TAGS" | grep -q "^$TAG$"; then
            echo "IMAGE_EXISTS=true" >> $GITHUB_OUTPUT
          else
            echo "IMAGE_EXISTS=false" >> $GITHUB_OUTPUT
            echo "Image $IMAGE_NAME:$TAG not found in $ACR_NAME."
          fi
        fi
      shell: bash

    - name: Launch Python Script to Kickoff Build Jobs
      if: steps.check_test_image.outputs.IMAGE_EXISTS == 'false'
      id: launch_script
      run: |
        PR_BRANCH=${{ inputs.branch_name }} \
        ACR_NAME=${{ inputs.acr_name }} \
        ACR_USERNAME=${{ inputs.acr_username }} \
        ACR_PASSWORD=${{ inputs.acr_password }} \
        MODEL_NAME=${{ inputs.model_name }} \
        MODEL_TYPE=${{ inputs.model_type }} \
        MODEL_VERSION=${{ inputs.model_version }} \
        MODEL_RUNTIME=${{ inputs.model_runtime }} \
        MODEL_TAG=${{ inputs.image_tag }} \
        WEIGHTS_DIR=${{ inputs.weights_dir }} \
        python3 .github/workflows/kind-cluster/main.py
      shell: bash

    - name: Check Python Script Status
      if: ${{ always() }}
      run: |
        if [[ "${{ inputs.image_already_built }}" == "true" ]]; then
          echo "Image already exists; skipping the status step."
        elif [[ "${{ steps.launch_script.outcome }}" != "success" ]]; then
          echo "Python script failed to execute successfully."
          exit 1  # Fail the job due to script failure
        else
          echo "Python script executed successfully."
        fi
      shell: bash

    - name: Cleanup
      if: ${{ always() }}
      run: |
        if [[ "${{ inputs.image_already_built }}" == "false" ]]; then
          kubectl get job --no-headers -o custom-columns=":metadata.name" | grep "^docker-build-job-${{ inputs.model_name }}-[0-9]" | xargs -r kubectl delete job
        fi
      shell: bash
